package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"os"
	"io/ioutil"
	"math/big"
	"golang.org/x/crypto/chacha20"
)

func main() {
	flagFile := "flag.png"
	flag, err := ioutil.ReadFile(flagFile)
	if err != nil {
		panic(err)
	}
	key := make([]byte, chacha20.KeySize)
	if _, err := rand.Read(key); err != nil {
		panic(err)
	}
	nonce := make([]byte, chacha20.NonceSize)
	if _, err := rand.Read(nonce); err != nil {
		panic(err)
	}

	k, err := chacha20.NewUnauthenticatedCipher(key, nonce)
	if err != nil {
		panic(err)
	}
	encryptedFlag := make([]byte, len(flag))
	k.XORKeyStream(encryptedFlag, flag)

    prefix := []byte("you_can't_break_me_:)")
    dataToEncrypt := append(prefix, append(append(nonce, key...), []byte("COPPERWAREEEEEEEEEE:)")...)...)
	rsaPublicKey := []byte{0x6C,0x64,0x7f,0x6c,0x64,0x10,0x04,0x0e,0x1b,0x0f,0x69,0x02,0x14,0x0b,0x1e,0x08,0x0a,0x72,0x0a,0x0c,0x0b,0x6c,0x64,0x7f,0x6c,0x64,0x5f,0x4b,0x04,0x1b,0x08,0x0b,0x1b,0x05,0x08,0x1c,0x03,0x2e,0x39,0x30,0x21,0x39,0x28,0x0e,0x6b,0x36,0x79,0x10,0x00,0x18,0x17,0x07,0x08,0x13,0x0e,0x0a,0x13,0x10,0x79,0x13,0x0c,0x00,0x1b,0x03,0x0a,0x13,0x0a,0x0a,0x13,0x10,0x0c,0x13,0x29,0x07,0x64,0x0a,0x23,0x15,0x12,0x3d,0x61,0x73,0x08,0x1e,0x2a,0x0a,0x27,0x38,0x1e,0x28,0x33,0x2f,0x5f,0x4b,0x30,0x1a,0x2c,0x70,0x2a,0x14,0x33,0x04,0x37,0x0a,0x3d,0x31,0x28,0x01,0x2c,0x1b,0x30,0x2f,0x24,0x0b,0x76,0x2a,0x35,0x2d,0x06,0x3e,0x19,0x04,0x1d,0x31,0x3f,0x17,0x2b,0x2f,0x0a,0x29,0x00,0x01,0x71,0x1d,0x36,0x39,0x07,0x20,0x27,0x0a,0x33,0x08,0x3b,0x2b,0x05,0x2a,0x04,0x79,0x70,0x2a,0x0b,0x24,0x31,0x38,0x30,0x05,0x77,0x2a,0x5f,0x4b,0x1b,0x23,0x31,0x01,0x14,0x07,0x3b,0x3f,0x6e,0x31,0x30,0x04,0x7f,0x60,0x10,0x78,0x23,0x3b,0x7f,0x3d,0x39,0x06,0x3c,0x27,0x20,0x20,0x74,0x3c,0x13,0x0a,0x7b,0x30,0x70,0x71,0x1a,0x77,0x7c,0x61,0x12,0x2d,0x33,0x23,0x7e,0x15,0x00,0x7c,0x65,0x19,0x39,0x35,0x0b,0x31,0x0b,0x30,0x3f,0x27,0x2a,0x28,0x2b,0x11,0x05,0x62,0x31,0x3d,0x5f,0x4b,0x22,0x64,0x31,0x62,0x26,0x18,0x28,0x0b,0x31,0x01,0x3f,0x77,0x06,0x0b,0x16,0x3f,0x3d,0x27,0x3d,0x1d,0x02,0x2a,0x33,0x71,0x04,0x33,0x08,0x01,0x1b,0x06,0x1d,0x20,0x35,0x31,0x27,0x0b,0x1a,0x3a,0x25,0x3d,0x61,0x28,0x39,0x0a,0x25,0x03,0x2b,0x13,0x0c,0x3b,0x10,0x3a,0x14,0x03,0x2a,0x3d,0x31,0x27,0x19,0x35,0x71,0x17,0x31,0x2a,0x5f,0x4b,0x01,0x14,0x3b,0x1f,0x33,0x11,0x28,0x31,0x05,0x0b,0x3f,0x38,0x13,0x37,0x19,0x1a,0x19,0x76,0x2b,0x6a,0x0c,0x03,0x15,0x6a,0x27,0x06,0x03,0x04,0x35,0x06,0x18,0x14,0x12,0x0b,0x6a,0x20,0x05,0x3e,0x0b,0x18,0x01,0x6a,0x7b,0x07,0x0e,0x20,0x22,0x27,0x33,0x22,0x24,0x07,0x16,0x18,0x7f,0x3e,0x2b,0x66,0x21,0x70,0x3a,0x30,0x28,0x10,0x5f,0x4b,0x13,0x7d,0x0a,0x31,0x3a,0x09,0x22,0x20,0x34,0x1a,0x63,0x2f,0x3d,0x00,0x15,0x3d,0x25,0x26,0x3b,0x03,0x75,0x1c,0x6b,0x05,0x1d,0x06,0x34,0x0b,0x1a,0x34,0x3c,0x67,0x10,0x0b,0x07,0x18,0x33,0x13,0x14,0x02,0x3e,0x0e,0x3d,0x67,0x75,0x03,0x03,0x00,0x2d,0x24,0x22,0x3a,0x17,0x2a,0x0d,0x17,0x76,0x2e,0x20,0x02,0x24,0x79,0x2c,0x08,0x5f,0x4b,0x03,0x25,0x08,0x0b,0x13,0x36,0x74,0x6f,0x4c,0x43,0x7f,0x6c,0x64,0x7f,0x6c,0x0c,0x1c,0x05,0x69,0x02,0x14,0x0b,0x1e,0x08,0x0a,0x72,0x0a,0x0c,0x0b,0x6c,0x64,0x7f,0x6c,0x64}  
    xorDecrypt := func(data []byte) []byte {
		key := []byte("AIR")
		result := make([]byte, len(data))
		for i := range data {
			result[i] = data[i] ^ key[i%len(key)]
		}
		return result
	}
	decryptedPublicKey := xorDecrypt(rsaPublicKey)

	block, _ := pem.Decode(decryptedPublicKey)
	publicKey, err := x509.ParsePKIXPublicKey(block.Bytes)

	if err != nil {
		panic(err)
	}
	rsaPubKey, _ := publicKey.(*rsa.PublicKey)
 
    c := new(big.Int).SetBytes(dataToEncrypt)
    encryptedKeyNonce := c.Exp(c, big.NewInt(int64(rsaPubKey.E)), rsaPubKey.N).Bytes()
    outputFile := "flag.png.copper"

	output, err := os.Create(outputFile)
	if err != nil {
		panic(err)
	}
	defer output.Close()

	_, err = output.Write(encryptedFlag)
	if err != nil {
		panic(err)
	}
	_, err = output.Write(encryptedKeyNonce)
	if err != nil {
		panic(err)
	}

}